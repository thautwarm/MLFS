
# SMLFS programming language v0.1

%%inline
from json.decoder import py_scanstring
def parse_str(s):
    return py_scanstring(s, 1)[0]

def str_concat(a, b):
    return a + b

def mk_tuple(T, xs):
    if len(xs) == 1:
        return xs[0]
    return T(xs)

def mk():
  TForall = "TForall"
  TApp = "TApp"
  TArrow = "TArrow"
  TTuple = "TTuple"
  TImplicit = "TImplicit"
  TVar = "TVar"
  TSym = "TSym"
  TNew = "TNew"
  TQuery = "TQuery"

  DAnn = "DAnn"
  DLoc = "DLoc"
  DBind = "DBind"
  DQuery = "DQuery"
  DOpen = "DOpen"

  ELoc = "ELoc"
  EVar = "EVar"
  EVal = "EVal"
  ELet = "ELet"
  EITE = "EITE"
  EFun = "EFun"
  EApp = "EApp"
  ETup = "ETup"
  EExt = "EExt"
  EQuery = "EQuery"
  EField = "EField"
  ModuleRecord = "ModuleRecord"
  I64 = "I64"
  F64 = "F64"
  Str = "Str"
  Bl = "Bl"
  out = {}

  for e in locals():
    def mk(e=e):
      def create(*args):
        if not args:
          return {'value': e}
        if len(args) is 1:
          return {e: args[0]}
        return {e: args}
      return create
    out[e] = mk()

  def Expr(pos, typ, impl):
    return {'pos':pos,  'typ': typ, 'impl': impl}
  def Pos(token):
    return {'line': token.lineno, 'col': token.colno, 'filename': token.filename}

  out['Expr'] = Expr
  out['Pos'] = Pos
  return out

globals().update(mk())

def concat(xs):
  if len(xs) == 1:
    return xs[0]
  res = []
  for x in xs:
    res.extend(x)
  return res

def importName(x):
  return x.split('.')[-1]

def inc(x):
  return x + 1
%%

list[p] : p         { [$1] }
        | list[p] p { $1.append($2); $1 }
        ;

sep_list[comma, p]
        : p                          { [$1] }
        | sep_list[comma, p] comma p { $1.append($3); $1 }
        ;

START : <BOF> toplevel <EOF> { $2 };

toplevel : 'module' nameStr
           list[import]
           list[declaration]
           { ModuleRecord($2, $3, concat($4)) }
          | 'module' nameStr
           list[declaration]
           { ModuleRecord($2, [], concat($3)) } ;

import : 'import' nameStr 'as' nameStr
          { ($2, $4) }
       | 'import' nameStr
          { ($2, importName($2)) }
        ;

tvar    : <name> { TVar($1.value) };

toptype : 'forall' list[nameStr] '.' toptype { TForall($2, $4) }
        |  arrowtype  { $1 }
        ;

arrowtype : calltype '->' toptype { TArrow($1, $3) }
          | calltype { $1 }
          ;

calltype : calltype type { TApp($1, $2) }
         | type          { $1 }
         ;

nameStr : <name> { $1.value };

type : tvar { $1 }
     | '(' ')'                        { TTuple([]) }
     | '(' sep_list[',', toptype] ')' { mk_tuple(TTuple, $2) }
     | '{' toptype '}' { TImplicit($2) }
     | <str> { TSym(parse_str($1.value)) }
     | '@' <name> { TNew($2.value) }
     | '?' type 'as' nameStr   { TQuery($4, $2) }
     ;

declaration : 'val' <name> ':' toptype
            { [DLoc(Pos($1)), DAnn($2.value, $4)] }
          | 'let' <name> '=' expr
            { [DLoc(Pos($1)), DBind($2.value, $4)] }
          | 'check' nameStr 'as' nameStr
            { [DLoc(Pos($1)), DQuery($4, $2)] }
          | 'open' expr
            { [DLoc(Pos($1)), DOpen($2)] }

          ;

expr : 'if' expr 'then' expr 'else' expr
       { EITE($2, $4, $6) }
     | list[declaration] 'in' expr
       { ELet(concat($1), $3) }
     | 'fun' <name> '->' expr
       { EFun($2.value, $4) }
     | call { $1 }
     ;

call : call atom { EApp($1, $2) }
     | atom { $1 }
     ;

atom : 'extern' <str> { EExt(parse_str($2.value))  }
     | '(' sep_list[',', expr] ')'
       { mk_tuple(ETup, $2) }
     | '(' ')' { ETup([]) }
     | <int> { EVal(I64(int($1.value))) }
     | <float> { EVal(F64(float($1.value))) }
     | <name> { EVar($1.value) }
     | <str> { EVal(Str(parse_str($1.value))) }
     | 'true' { EVal(Bl(True)) }
     | 'false' { EVal(Bl(False)) }
     | atom '.' nameStr
      { EField($1, $3) }
     | '?'  atom 'as' nameStr
      { EQuery($4, $2) }
     ;
